"""
This is an example script to generate 2nd and 3rd order force constants using phono3py for
rocksalt and zincblende structures.
One will typically want to modify this script to fit their own needs, for example,
customize the inputs and protocols for VASP calculations.
"""

import click
import typing as t

from aiida_workgraph import task
from aiida_workgraph import dynamic, namespace

from aiida_vasp.workchains.v2.vasp import VaspWorkChain
from aiida_vasp.workchains.v2.relax import VaspRelaxWorkChain
from aiida_vasp.protocols.generator import VaspInputGenerator, VaspRelaxInputGenerator

from aiida_workgraph import shelljob
from aiida import orm
from pymatgen.core import Structure
from pathlib import Path
import ase

VaspTask = task(VaspWorkChain)
VaspRelaxTask = task(VaspRelaxWorkChain)


def parse_displacements(dirpath: Path):
    """
    Parse the outputs from a folder after running phono3py -d command as StructureData and SingleFileData
    """
    # Read the files are StructureData
    outputs = {}
    for file in Path(dirpath).glob("POSCAR*"):
        structure = orm.StructureData(pymatgen=Structure.from_file(file))
        outputs[file.stem.replace("-", "_")] = structure
    # Save the phono3py_disp.yaml
    yaml_data = orm.SinglefileData(file=dirpath / "phono3py_disp.yaml")
    outputs["phono3py_disp"] = yaml_data
    return outputs


@task.graph
def generate_displacements(
    code: orm.Code,
    structure: orm.StructureData,
    dim3: int = 2,
    dim2: int = 4,
    amplitude: float = 0.03,
) -> t.Annotated[
    dict,
    namespace(phono3py_out=dynamic(t.Any)),
]:
    """
    Returns the displacement structures generated by phono3py.
    """
    if isinstance(structure, ase.Atoms):
        structure = Structure.from_ase_atoms(structure)
    elif isinstance(structure, orm.StructureData):
        structure = structure.get_pymatgen()

    poscar_node = orm.SinglefileData.from_string(structure.to(fmt="poscar"), filename="POSCAR.vasp")
    out = shelljob(
        command=code,
        arguments=[
            "-c",
            "POSCAR.vasp",
            "-d",
            "--dim",
            str(dim3),
            str(dim3),
            str(dim3),
            "--dim-fc2",
            str(dim2),
            str(dim2),
            str(dim2),
            "--amplitude",
            str(amplitude),
            "--pa",
            "F",
        ],
        nodes={
            "poscar_node": poscar_node,
        },
        parser=parse_displacements,
        metadata={
            "options": {
                "additional_retrieve": ["POSCAR*", "*.yaml"],
                "prepend_text": "conda deactivate\nconda deactivate\nunset PYTHONPATH\nenv",
            }
        },
    )
    return {"phono3py_out": out}


def get_inputs_relax(structure, kind, mp_id, protocol="balanced@phonondb"):
    """
    Get builder for the initial geometry optimisation calculation
    """
    upd = VaspRelaxInputGenerator(protocol)
    upd.get_builder(
        structure,
        options={
            "max_wallclock_seconds": 3600 * 8,
            "resources": {"tot_num_mpiprocs": 4, "num_machines": 1},
        },
        code="vasp-6.5.0-std@catapult",
    )
    upd.set_label(f"{kind} {mp_id} PhononDB RELAX PBE_54")
    upd.set_incar(algo="all")
    upd.set_relax_settings(force_cutoff=0.001)
    upd.set_kspacing(0.03)
    return upd.builder._inputs(prune=True)


second_order_overrides = {
    "parameters": {
        "incar": {
            "ncore": 8,
            "ispin": 1,
        }
    }
}

third_order_overrides = {
    "parameters": {
        "incar": {
            "ncore": 4,
            "ispin": 1,
        }
    }
}


@task.graph
def launch_second_third_order_calculations(
    disp_out: t.Annotated[dict, dynamic(t.Any)],
    kind: str,
) -> t.Annotated[dict, namespace(calc_retrieved=dynamic(t.Any))]:
    """
    Launch second and third order calculations
    NOTE: you may want to define your own input settings for VASP calculations here
    """
    # Deserialize if needed
    if hasattr(kind, "value"):
        kind = kind.value

    def get_inputs_second_order(structure, kind, fname, protocol="balanced@phonondb"):
        """
        Get builder for second order force constants calculations
        """
        upd = VaspInputGenerator()
        upd.get_builder(
            structure,
            protocol=protocol,
            code="vasp-6.5.0-gpu-gam@catapult-srun",
            overrides=second_order_overrides,
            options={
                "max_wallclock_seconds": 48 * 3600,
                "qos": "urgent",
                "queue_name": "gpu",
                "prepend_text": "export OMP_NUM_TRHEADS=$SLURM_CPUS_PER_TASK",  # Run with OMP
                "custom_scheduler_commands": "#SBATCH --gres=gpu:4090:2",
                "resources": {
                    "num_machines": 1,
                    "tot_num_mpiprocs": 2,
                    "num_cores_per_mpiproc": 8,
                },
            },
        )
        upd.set_kpoints_mesh((1, 1, 1))  # For RS and ZB use gamma only
        upd.set_label(f"{kind} {fname}")
        del upd.builder.magmom_mapping
        return upd.builder._inputs(prune=True)

    def get_inputs_third_order(structure, kind, fname, protocol="balanced@phonondb"):
        """
        Get builder for third order force constants calculations
        """
        upd = VaspInputGenerator()
        upd.get_builder(
            structure,
            protocol=protocol,
            code="vasp-6.4.2@sugon-tai",  # SUGON HPC resources
            overrides=third_order_overrides,
            options={
                "max_wallclock_seconds": 24 * 3600,
                "resources": {"num_machines": 1, "tot_num_mpiprocs": 32},
                "queue_name": "tyhcnormal",
            },
        )
        upd.set_kpoints_mesh((2, 2, 2))  # Gamma-centred 222 grid
        upd.set_label(f"{kind} {fname}")
        # upd.set_label(f'{kind} {fname}')
        del upd.builder.magmom_mapping
        return upd.builder._inputs(prune=True)

    calc_retrieved = {}
    second_order_inputs = None
    third_order_inputs = None
    for key, value in disp_out.items():
        if "POSCAR_FC2" in key:
            if second_order_inputs is None:
                second_order_inputs = get_inputs_second_order(value, kind, key)
            second_order_inputs["structure"] = value
            second_order_inputs["metadata"]["label"] = f"{kind} {key}"
            calc_retrieved[key] = VaspTask(**second_order_inputs).retrieved
        # Third order calculations
        elif "POSCAR_" in key:
            if third_order_inputs is None:
                third_order_inputs = get_inputs_third_order(value, kind, key)
            third_order_inputs["structure"] = value
            third_order_inputs["metadata"]["label"] = f"{kind} {key}"
            calc_retrieved[key] = VaspTask(**third_order_inputs).retrieved
    return {"calc_retrieved": calc_retrieved}


@task.graph
def generate_phono3py_param(
    retrieved: t.Annotated[dict, dynamic(t.Any)],
    code: orm.Code,
    disps: t.Annotated[dict, dynamic(t.Any)],
) -> t.Annotated[dict, namespace(phono3py_out=t.Any)]:
    """Generate phono3py parameters with phono3py_disp.yaml and calculations results as inputs"""
    # Write the vasprun.xml files
    # Run phono3py commandline

    arguments_fc3 = [
        "--cf3",
    ]
    arguments_fc2 = [
        "--cf2",
    ]
    files = {"phono3py_disp": disps["phono3py_disp"]}  # Include the phono3py_disp.yaml file in the submission folder
    # Include the vasprun.xml files as POSCAR-00000.xml and POSCAR_FC2-000.xml
    for key, value in retrieved.items():
        if key.startswith("POSCAR"):
            node = orm.SinglefileData.from_string(value.get_object_content("vasprun.xml"), filename=key + ".xml")
            files[key] = node
            if "FC2" in key:
                arguments_fc2.append(key + ".xml")
            else:
                arguments_fc3.append(key + ".xml")
    # Sort the arguments in the order of POSCAR_00001.xml, POSCAR_00002.xml etc
    arguments_fc3 = arguments_fc3[:1] + sorted(arguments_fc3[1:])
    arguments_fc2 = arguments_fc2[:1] + sorted(arguments_fc2[1:])
    # Run the shell job
    out = shelljob(
        command=code,
        arguments=arguments_fc2 + arguments_fc3 + ["--sp", "--fc-symmetry", "--pa", "F"],
        nodes=files,
        outputs=["phono3py_params.yaml"],  # Output a SingleFileData sorting the phono3py_params.yaml
        metadata={
            "options": {
                "additional_retrieve": ["*.yaml"],
                "prepend_text": "unset PYTHONPATH",
            }
        },
    )
    return {"phono3py_out": out.phono3py_params_yaml}


@task.graph
def run_phono3py_rs_zb(
    initial_structure,
    kind: str,
    mp_id: str,
    phono3py_code: orm.Code,
):
    """
    Run phono3py calculation for rocksalt or zincblende structures

    Returns a SingleFileData node of the phono3py_params.yaml file which contains
    the force constants needed to run LTC calculation
    """

    # Perform relaxation
    relaxed = VaspRelaxTask(**get_inputs_relax(initial_structure, kind, mp_id)).relax.structure
    # Generate displacement
    gen_disps = generate_displacements(
        structure=relaxed, code=phono3py_code
    ).phono3py_out  # Make gen_disps an output of a task instead of a graph
    # Launch calculations in parallel
    retrieved = launch_second_third_order_calculations(disp_out=gen_disps, kind=kind).calc_retrieved
    # Generate phono3py_param.yaml
    return generate_phono3py_param(retrieved=retrieved, disps=gen_disps, code=phono3py_code).phono3py_out


@click.command()
@click.argument("material_id")
@click.argument("structure_file", type=click.Path(exists=True))
@click.argument("phono3py_code")
@click.option("--max-concurrent", default=50, help="Maximum number of concurrent jobs")
def main(structure_file, material_id, phono3py_code, max_concurrent=50):
    """
    Launch a workflow to generate 2nd and 3rd order force constants using phono3py for a given structure file.
    """
    structure = Structure.from_file(structure_file)
    formula = structure.composition.reduced_formula
    wg = run_phono3py_rs_zb.build(
        orm.StructureData(pymatgen=structure),
        formula,
        material_id,
        phono3py_code=orm.load_code(phono3py_code),
    )
    wg.max_number_jobs = max_concurrent  # Limit the concurrent tasks
    process = wg.submit()
    process.label = formula + " " + material_id + " FC23"
    return process


if __name__ == "__main__":
    main()
